<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trình Chiếu từ JSON</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .slide-container {
            width: 100%;
            max-width: 1000px;
            margin: 20px 0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            background-color: white;
        }
        
        .slide {
            position: relative;
            width: 100%;
            height: 560px;
            overflow: hidden;
            display: none;
        }
        
        .shape {
            position: absolute;
        }
        
        .text-element {
            position: absolute;
            font-family: Arial, sans-serif;
            color: #333;
        }
        
        .line-element {
            position: absolute;
            background-color: #5b9bd5;
        }
        
        .slide-navigation {
            margin: 10px 0;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 8px 16px;
            background-color: #5b9bd5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #4a8bc4;
        }
        
        .triangle-text {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            height: 100%;
            text-align: center;
            transform-origin: center;
        }
        
        .triangle-text-container {
            position: absolute;
            width: 60%;
            height: 60%;
            top: 20%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            opacity: inherit;
        }
        
        .triangle-text p {
            width: 10px;
            height: 8px;
            background-color: transparent;
            cursor: pointer;
            margin-top: 3px;
            margin: 6px;
            font-size: 100%;
            line-height: 1.2;
            padding: 10;
            display: flex;
            flex-direction: column
        }
        
        #file-info {
            margin-left: 10px;
            font-style: italic;
            color: #666;
        }

        .line-element {
            position: absolute;
            transform-origin: 0 0;
        }

        .line-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 2;
        }

        .line-dot {
            position: absolute;
            pointer-events: none;
            z-index: 2;
        }

        .svg-line-container {
            overflow: visible;
        }

        .line-with-shadow {
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.3));
        }
    </style>
</head>
<body>
    <div class="controls">
        <input type="file" id="json-file" accept=".json">
        <span id="file-info">Chưa có file nào được chọn</span>
    </div>
    
    <div class="slide-container" id="slide-container">
    </div>

    <script>
        let currentSlides = [];
        let currentSlideIndex = 0;
        
        // Xử lý khi chọn file
        document.getElementById('json-file').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('file-info').textContent = file.name;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const slidesData = JSON.parse(e.target.result);
                    loadSlides(slidesData);
                } catch (error) {
                    alert('Lỗi khi đọc file JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        });
        
        // Tải slides từ dữ liệu JSON
        function loadSlides(slidesData) {
            const container = document.getElementById('slide-container');
            container.innerHTML = '';
            currentSlides = [];
            
            if (!Array.isArray(slidesData)) {
                alert('Dữ liệu JSON không hợp lệ');
                return;
            }
            
            slidesData.forEach((slideData, index) => {
                const slide = createSlide(slideData, index);
                container.appendChild(slide);
                currentSlides.push(slide);
            });
            
            if (currentSlides.length > 0) {
                showSlide(0);
            }
            
            createNavigationButtons();
        }
        
        function createSlide(slideData, index) {
            const slide = document.createElement('div');
            slide.className = 'slide';
            slide.id = `slide-${index}`;
            
            if (!slideData.elements || !Array.isArray(slideData.elements)) {
                slide.innerHTML = '<p>Slide không có dữ liệu hợp lệ</p>';
                return slide;
            }
            
            if (slideData.background) {
                if (slideData.background.type === 'solid') {
                    slide.style.backgroundColor = slideData.background.color || '#ffffff';
                } else if (slideData.background.type === 'gradient') {
                    const gradient = slideData.background.gradient;
                    if (gradient.type === 'linear') {
                        slide.style.background = `linear-gradient(${gradient.angle || 0}deg, ${gradient.stops.join(', ')})`;
                    } else if (gradient.type === 'radial') {
                        slide.style.background = `radial-gradient(circle at ${gradient.centerX || '50%'} ${gradient.centerY || '50%'}, ${gradient.stops.join(', ')})`;
                    }
                }
            }
            
            // Tạo các phần tử trong slide
            slideData.elements.forEach(element => {
                switch (element.type) {
                    case 'shape':
                        drawShape(element, slide);
                        break;
                    case 'text':
                        createTextElement(element, slide);
                        break;
                    case 'line':
                        drawLine(element, slide);
                        break;
                }
            });
            
            return slide;
        }
        
        function drawShape(element, slide) {
            const shape = document.createElement('div');
            shape.className = 'shape';

            // Tính toán vị trí và kích thước
            const width = element.width || 100;
            const height = element.height || 100;

            // Đặt transform origin vào giữa hình dạng
            shape.style.transformOrigin = 'center center';

            shape.style.left = `${element.left}px`;
            shape.style.top = `${element.top}px`;
            shape.style.width = `${element.width}px`;
            shape.style.height = `${element.height}px`;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${element.viewBox?.[0] || width} ${element.viewBox?.[1] || height}`);
            svg.setAttribute('preserveAspectRatio', 'none');
            
            // Tạo gradient nếu có
            let gradientId = null;
            if (element.fill && element.fill.type === 'gradient') {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                gradientId = `gradient-${Math.random().toString(36).substr(2, 9)}`;
                
                if (element.fill.gradient.type === 'linear') {
                    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                    gradient.setAttribute('id', gradientId);
                    gradient.setAttribute('x1', element.fill.gradient.x1 || '0%');
                    gradient.setAttribute('y1', element.fill.gradient.y1 || '0%');
                    gradient.setAttribute('x2', element.fill.gradient.x2 || '100%');
                    gradient.setAttribute('y2', element.fill.gradient.y2 || '0%');
                    gradient.setAttribute('gradientTransform', `rotate(${element.gradient.rotate || 0})`);
                    
                    element.fill.gradient.stops.forEach(stop => {
                        const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                        stopElement.setAttribute('offset', stop.offset);
                        stopElement.setAttribute('stop-color', stop.color);
                        if (stop.opacity) stopElement.setAttribute('stop-opacity', stop.opacity);
                        gradient.appendChild(stopElement);
                    });
                    
                    defs.appendChild(gradient);
                } else if (element.fill.gradient.type === 'radial') {
                    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', gradientId);
                    gradient.setAttribute('cx', element.fill.gradient.cx || '50%');
                    gradient.setAttribute('cy', element.fill.gradient.cy || '50%');
                    gradient.setAttribute('r', element.fill.gradient.r || '50%');
                    gradient.setAttribute('fx', element.fill.gradient.fx || element.fill.gradient.cx || '50%');
                    gradient.setAttribute('fy', element.fill.gradient.fy || element.fill.gradient.cy || '50%');
                    
                    element.fill.gradient.stops.forEach(stop => {
                        const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                        stopElement.setAttribute('offset', stop.offset);
                        stopElement.setAttribute('stop-color', stop.color);
                        if (stop.opacity) stopElement.setAttribute('stop-opacity', stop.opacity);
                        gradient.appendChild(stopElement);
                    });
                    
                    defs.appendChild(gradient);
                }
                
                svg.appendChild(defs);
            }
            
            let path;
            if (element.shapeType) {
                switch (element.shapeType.toLowerCase()) {
                    case 'rectangle':
                    case 'rect':
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', '0');
                        rect.setAttribute('y', '0');
                        rect.setAttribute('width', '100%');
                        rect.setAttribute('height', '100%');
                        
                        // Xử lý fill
                        if (gradientId) {
                            rect.setAttribute('fill', `url(#${gradientId})`);
                        } else {
                            rect.setAttribute('fill', element.fill?.color || element.fill || '#5b9bd5');
                        }
                        
                        rect.setAttribute('opacity', element.opacity || 1);
                        
                        // Xử lý đường viền
                        if (element.borderWidth && element.borderWidth > 0) {
                            rect.setAttribute('stroke', element.borderColor || '#000000');
                            rect.setAttribute('stroke-width', element.borderWidth);
                            
                            // Xử lý kiểu đường viền
                            if (element.borderStyle) {
                                switch(element.borderStyle.toLowerCase()) {
                                    case 'dashed':
                                        rect.setAttribute('stroke-dasharray', `${element.borderWidth * 3},${element.borderWidth * 2}`);
                                        break;
                                    case 'dotted':
                                        rect.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                    case 'double':
                                        rect.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                }
                            }
                        }
                        
                        if (element.rx) rect.setAttribute('rx', element.rx);
                        if (element.ry) rect.setAttribute('ry', element.ry);
                        svg.appendChild(rect);
                        break;
                        
                    case 'circle':
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', '50%');
                        circle.setAttribute('cy', '50%');
                        circle.setAttribute('r', '50%');
                        
                        // Xử lý fill
                        if (gradientId) {
                            circle.setAttribute('fill', `url(#${gradientId})`);
                        } else {
                            circle.setAttribute('fill', element.fill?.color || element.fill || '#5b9bd5');
                        }
                        
                        circle.setAttribute('opacity', element.opacity || 1);
                        
                        // Xử lý border
                        if (element.borderWidth && element.borderWidth > 0) {
                            circle.setAttribute('stroke', element.borderColor || '#000000');
                            circle.setAttribute('stroke-width', element.borderWidth);
                            
                            // Xử lý kiểu border
                            if (element.borderStyle) {
                                switch(element.borderStyle.toLowerCase()) {
                                    case 'dashed':
                                        circle.setAttribute('stroke-dasharray', `${element.borderWidth * 3},${element.borderWidth * 2}`);
                                        break;
                                    case 'dotted':
                                        circle.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                    case 'double':
                                        circle.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                }
                            }
                        }
                        
                        svg.appendChild(circle);
                        break;
                        
                    case 'ellipse':
                        const ellipse = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                        ellipse.setAttribute('cx', '50%');
                        ellipse.setAttribute('cy', '50%');
                        ellipse.setAttribute('rx', '50%');
                        ellipse.setAttribute('ry', '30%');
                        
                        // Xử lý fill
                        if (gradientId) {
                            ellipse.setAttribute('fill', `url(#${gradientId})`);
                        } else {
                            ellipse.setAttribute('fill', element.fill?.color || element.fill || '#5b9bd5');
                        }
                        
                        ellipse.setAttribute('opacity', element.opacity || 1);
                        
                        // Xử lý border
                        if (element.borderWidth && element.borderWidth > 0) {
                            ellipse.setAttribute('stroke', element.borderColor || '#000000');
                            ellipse.setAttribute('stroke-width', element.borderWidth);
                            
                            // Xử lý kiểu border
                            if (element.borderStyle) {
                                switch(element.borderStyle.toLowerCase()) {
                                    case 'dashed':
                                        ellipse.setAttribute('stroke-dasharray', `${element.borderWidth * 3},${element.borderWidth * 2}`);
                                        break;
                                    case 'dotted':
                                        ellipse.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                    case 'double':
                                        ellipse.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                }
                            }
                        }
                        
                        svg.appendChild(ellipse);
                        break;
                        
                    case 'polygon':
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        const points = element.points || '0,0 100,0 50,100';
                        polygon.setAttribute('points', points);
                        
                        // Xử lý fill
                        if (gradientId) {
                            polygon.setAttribute('fill', `url(#${gradientId})`);
                        } else {
                            polygon.setAttribute('fill', element.fill?.color || element.fill || '#5b9bd5');
                        }
                        
                        polygon.setAttribute('opacity', element.opacity || 1);
                        
                        // Xử lý border
                        if (element.borderWidth && element.borderWidth > 0) {
                            polygon.setAttribute('stroke', element.borderColor || '#000000');
                            polygon.setAttribute('stroke-width', element.borderWidth);
                            
                            // Xử lý kiểu border
                            if (element.borderStyle) {
                                switch(element.borderStyle.toLowerCase()) {
                                    case 'dashed':
                                        polygon.setAttribute('stroke-dasharray', `${element.borderWidth * 3},${element.borderWidth * 2}`);
                                        break;
                                    case 'dotted':
                                        polygon.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                    case 'double':
                                        polygon.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                }
                            }
                        }
                        
                        svg.appendChild(polygon);
                        break;
                        
                    case 'line':
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', element.x1 || '0');
                        line.setAttribute('y1', element.y1 || '0');
                        line.setAttribute('x2', element.x2 || '100%');
                        line.setAttribute('y2', element.y2 || '100%');
                        line.setAttribute('stroke', element.stroke || '#5b9bd5');
                        line.setAttribute('stroke-width', element.strokeWidth || 2);
                        line.setAttribute('opacity', element.opacity || 1);
                        svg.appendChild(line);
                        break;
                        
                    default:
                        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', element.path || 'M0,0 L100,0 L50,100 Z');
                        
                        // Xử lý fill
                        if (gradientId) {
                            path.setAttribute('fill', `url(#${gradientId})`);
                        } else {
                            path.setAttribute('fill', element.fill?.color || element.fill || '#5b9bd5');
                        }
                        
                        path.setAttribute('opacity', element.opacity || 1);
                        
                        // Xử lý border
                        if (element.borderWidth && element.borderWidth > 0) {
                            path.setAttribute('stroke', element.borderColor || '#000000');
                            path.setAttribute('stroke-width', element.borderWidth);
                            
                            // Xử lý kiểu border
                            if (element.borderStyle) {
                                switch(element.borderStyle.toLowerCase()) {
                                    case 'dashed':
                                        path.setAttribute('stroke-dasharray', `${element.borderWidth * 3},${element.borderWidth * 2}`);
                                        break;
                                    case 'dotted':
                                        path.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                    case 'double':
                                        path.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                        break;
                                }
                            }
                        }
                        
                        svg.appendChild(path);
                }
            } else {
                path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', element.path || 'M0,0 L100,0 L50,100 Z');
                
                // Xử lý fill
                if (gradientId) {
                    path.setAttribute('fill', `url(#${gradientId})`);
                } else {
                    path.setAttribute('fill', element.fill?.color || element.fill || '#5b9bd5');
                }
                
                path.setAttribute('opacity', element.opacity || 1);
                
                // Xử lý border
                if (element.borderWidth && element.borderWidth > 0) {
                    path.setAttribute('stroke', element.borderColor || '#000000');
                    path.setAttribute('stroke-width', element.borderWidth);
                    
                    // Xử lý kiểu border
                    if (element.borderStyle) {
                        switch(element.borderStyle.toLowerCase()) {
                            case 'dashed':
                                path.setAttribute('stroke-dasharray', `${element.borderWidth * 3},${element.borderWidth * 2}`);
                                break;
                            case 'dotted':
                                path.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                break;
                            case 'double':
                                path.setAttribute('stroke-dasharray', `${element.borderWidth},${element.borderWidth}`);
                                break;
                        }
                    }
                }
                
                svg.appendChild(path);
            }
            
            // Áp dụng transform cho cả SVG và shape container nếu cần
            let svgTransform = '';
            let shapeTransform = '';

            // Xử lý flip và rotate
            if (element.flipV) {
                svgTransform += ' scale(1,-1)';
            }
            if (element.flipH) {
                svgTransform += ' scale(-1,1)';
            }
            if (element.rotate) {
                // Áp dụng rotate cho shape container để giữ nguyên vị trí
                shapeTransform += ` rotate(${element.rotate}deg)`;
                shape.style.transformOrigin = 'center center';
            }
            
            if (svgTransform) {
                svg.setAttribute('transform', svgTransform.trim());
            }
            if (shapeTransform) {
                shape.style.transform = shapeTransform.trim();
            }
            
            shape.appendChild(svg);
            
            // Thêm text nếu có
            if (element.text && element.text.content) {
                const textContainer = document.createElement('div');
                textContainer.className = 'triangle-text-container';
                textContainer.style.transformOrigin = 'center center';
                
                if (element.opacity !== undefined) {
                    textContainer.style.opacity = element.opacity;
                }

                // Áp dụng flip cho text container nếu cần
                let textTransform = '';
                if (element.flipV) {
                    textTransform += ' scaleY(-1)';
                }
                if (element.flipH) {
                    textTransform += ' scaleX(-1)';
                }
                if (textTransform) {
                    textContainer.style.transform = textTransform.trim();
                }
                
                const textDiv = document.createElement('div');
                textDiv.className = 'triangle-text';
                
                // Áp dụng căn chỉnh text
                if (element.text.align) {
                    textDiv.style.textAlign = element.text.align;
                    textDiv.style.width = '100%';
                    textDiv.style.display = 'flex';
                    textDiv.style.justifyContent = 
                        element.text.align === 'left' ? 'flex-start' :
                        element.text.align === 'right' ? 'flex-end' : 'center';
                }
                
                textDiv.innerHTML = element.text.content;
                textContainer.appendChild(textDiv);
                shape.appendChild(textContainer);
            }
            
            slide.appendChild(shape);
        }
        
        function drawLine(element, slide) {
            const lineContainer = document.createElement('div');
            lineContainer.className = 'svg-line-container';
            lineContainer.style.position = 'absolute';
            lineContainer.style.left = `${element.left}px`;
            lineContainer.style.top = `${element.top}px`;
            lineContainer.style.width = '100%';
            lineContainer.style.height = '100%';

            if (element.shadow) {
                lineContainer.classList.add('line-with-shadow');
                const shadow = element.shadow;
                lineContainer.style.filter = `drop-shadow(${shadow.h || 0}px ${shadow.v || 0}px ${shadow.blur || 0}px ${shadow.color || '#000'})`;
            }

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.style.overflow = 'visible';
            
            // Tạo defs cho các marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            svg.appendChild(defs);

            // Kích thước mũi tên dựa trên độ rộng đường kẻ
            const arrowSize = (element.width || 1) + 0.5;

            // Tạo marker cho mũi tên (đầu bắt đầu) - ngược hướng
            let arrowStartMarkerId = null;
            if (element.points && element.points[0] === 'arrow') {
                arrowStartMarkerId = `arrowhead-start-${Math.random().toString(36).substr(2, 9)}`;
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', arrowStartMarkerId);
                marker.setAttribute('markerWidth', arrowSize);
                marker.setAttribute('markerHeight', arrowSize);
                marker.setAttribute('refX', arrowSize * 0.5); // Điểm neo vào đầu đường kẻ
                marker.setAttribute('refY', arrowSize / 2);
                marker.setAttribute('orient', 'auto');
                const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                // Tam giác đều hướng ngược lại
                arrowPath.setAttribute('d', `M${arrowSize},0 L0,${arrowSize/2} L${arrowSize},${arrowSize} Z`);
                arrowPath.setAttribute('fill', element.color || '#5b9bd5');
                marker.appendChild(arrowPath);
                defs.appendChild(marker);
            }
            
            // Tạo marker cho mũi tên (đầu cuối)
            let arrowEndMarkerId = null;
            if ((element.points && element.points[0] === 'arrow') || 
                (element.points && element.points[1] === 'arrow')) {
                arrowEndMarkerId = `arrowhead-end-${Math.random().toString(36).substr(2, 9)}`;
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', arrowEndMarkerId);
                marker.setAttribute('markerWidth', arrowSize);
                marker.setAttribute('markerHeight', arrowSize);
                marker.setAttribute('refX', arrowSize * 0.9); // Điểm neo vào cuối đường kẻ
                marker.setAttribute('refY', arrowSize / 2);
                marker.setAttribute('orient', 'auto');
                const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                // Tam giác đều hướng về phía trước
                arrowPath.setAttribute('d', `M0,0 L${arrowSize},${arrowSize/2} L0,${arrowSize} Z`);
                arrowPath.setAttribute('fill', element.color || '#5b9bd5');
                marker.appendChild(arrowPath);
                defs.appendChild(marker);
            }

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Xác định dạng đường kẻ
            let pathData = '';
            if (element.cubic) {
                pathData = `M${element.start?.[0] || 0} ${element.start?.[1] || 0} 
                        C${element.cubic[0][0]} ${element.cubic[0][1]} 
                        ${element.cubic[1][0]} ${element.cubic[1][1]} 
                        ${element.end[0]} ${element.end[1]}`;
            } else if (element.curve) {
                pathData = `M${element.start?.[0] || 0} ${element.start?.[1] || 0} 
                        Q${element.curve[0]} ${element.curve[1]} 
                        ${element.end[0]} ${element.end[1]}`;
            } else if (element.broken) {
                // Đường gấp khúc
                pathData = `M${element.start?.[0] || 0} ${element.start?.[1] || 0} 
                        L${element.broken[0]} ${element.broken[1]} 
                        L${element.end[0]} ${element.end[1]}`;
            } else {
                // Đường thẳng
                pathData = `M${element.start?.[0] || 0} ${element.start?.[1] || 0} 
                        L${element.end[0]} ${element.end[1]}`;
            }
            
            line.setAttribute('d', pathData);
            line.setAttribute('stroke', element.color || '#5b9bd5');
            line.setAttribute('stroke-width', element.width || 2);
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('stroke-linejoin', 'round');
            line.setAttribute('fill', 'none');
            
            // Xử lý các kiểu đường kẻ
            if (element.style) {
                switch(element.style.toLowerCase()) {
                    case 'dashed':
                        const dashLength = Math.max(3, element.width || 2) * 3.5;
                        const gapLength = Math.max(2, element.width || 2) * 2.5;
                        line.setAttribute('stroke-dasharray', `${dashLength},${gapLength}`);
                        break;
                    case 'custom':
                        if (element.dashArray) {
                            line.setAttribute('stroke-dasharray', element.dashArray);
                        }
                        break;
                        case 'double':
                    // Tạo hiệu ứng đường kép
                    line.setAttribute('stroke', 'transparent');
                    line.setAttribute('stroke-width', (element.width || 2) * 3);
                    line.setAttribute('stroke-linecap', 'butt');
                    
                    const innerLine = line.cloneNode();
                    innerLine.setAttribute('stroke', element.color || '#5b9bd5');
                    innerLine.setAttribute('stroke-width', element.width || 2);
                    svg.appendChild(innerLine);
                    break;
                }
            }

            // Xử lý chấm ở điểm đầu và cuối
            const dotRadius = (element.width || 2) * 2;
            const dotColor = element.color || '#5b9bd5';
            
            // Xử lý điểm đầu và điểm cuối
            if (element.points) {
                if (element.points[0] === 'arrow' && arrowStartMarkerId) {
                    line.setAttribute('marker-start', `url(#${arrowStartMarkerId})`);
                }
                if (element.points[1] === 'arrow' && arrowEndMarkerId) {
                    line.setAttribute('marker-end', `url(#${arrowEndMarkerId})`);
                }
            }

            // Điểm bắt đầu
            if (element.start && element.points && element.points[0] === 'dot') {
                const startDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                startDot.setAttribute('cx', element.start[0]);
                startDot.setAttribute('cy', element.start[1]);
                startDot.setAttribute('r', dotRadius);
                startDot.setAttribute('fill', dotColor);
                svg.appendChild(startDot);
            }
            
            // Điểm kết thúc
            if (element.end && element.points && element.points[1] === 'dot') {
                const endDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                endDot.setAttribute('cx', element.end[0]);
                endDot.setAttribute('cy', element.end[1]);
                endDot.setAttribute('r', dotRadius);
                endDot.setAttribute('fill', dotColor);
                svg.appendChild(endDot);
            }
            
            // Điểm gấp khúc (nếu có)
            if (element.broken && element.brokenPoint === 'dot') {
                const brokenDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                brokenDot.setAttribute('cx', element.broken[0]);
                brokenDot.setAttribute('cy', element.broken[1]);
                brokenDot.setAttribute('r', dotRadius);
                brokenDot.setAttribute('fill', dotColor);
                svg.appendChild(brokenDot);
            }
            
            svg.appendChild(line);
            lineContainer.appendChild(svg);
            slide.appendChild(lineContainer);
        }
        
        // Tạo phần tử văn bản
        function createTextElement(element, slide) {
            const text = document.createElement('div');
            text.className = 'text-element';
            text.style.left = `${element.left}px`;
            text.style.top = `${element.top}px`;
            text.style.width = `${element.width}px`;
            text.style.height = `${element.height}px`;
            
            if (element.rotate) {
                text.style.transform = `rotate(${element.rotate}deg)`;
            }
            
            if (element.lineHeight) {
                text.style.lineHeight = `${element.lineHeight}`;
            }
            
            if (element.defaultColor) {
                text.style.color = element.defaultColor;
            }
            
            text.innerHTML = element.content;
            slide.appendChild(text);
        }
        
        // Tạo nút điều hướng
        function createNavigationButtons() {
            const existingNav = document.querySelector('.slide-navigation');
            if (existingNav) existingNav.remove();
            
            if (currentSlides.length <= 1) return;
            
            const nav = document.createElement('div');
            nav.className = 'slide-navigation';
            
            for (let i = 0; i < currentSlides.length; i++) {
                const button = document.createElement('button');
                button.textContent = `Slide ${i + 1}`;
                button.onclick = () => showSlide(i);
                nav.appendChild(button);
            }
            
            document.querySelector('.slide-container').after(nav);
        }
        
        // Hiển thị slide được chọn
        function showSlide(index) {
            if (index < 0 || index >= currentSlides.length) return;
            
            currentSlides.forEach(slide => {
                slide.style.display = 'none';
            });
            
            currentSlides[index].style.display = 'block';
            currentSlideIndex = index;
        }
    </script>
</body>
</html>